# index.html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Luka2 — Gyro Projectiles w/ Angle Limits</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#e5e7eb;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}
  #runBtn{position:fixed;right:16px;bottom:20px;background:#2563eb;color:#fff;border:0;border-radius:14px;
          padding:14px 18px;font-weight:700;box-shadow:0 6px 18px rgba(0,0,0,.25);z-index:20}
  #prompt{position:fixed;top:12px;left:50%;transform:translateX(-50%);background:#facc15;color:#111;
          padding:10px 12px;border-radius:10px;box-shadow:0 6px 16px rgba(0,0,0,.25);font-size:14px;display:none;z-index:30}
  #hud{position:fixed;bottom:12px;left:12px;background:rgba(0,0,0,.55);color:#fff;border-radius:10px;padding:8px 10px;
       font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,monospace;z-index:20}
  .panel{position:fixed;top:12px;left:12px;background:#fff;border-radius:12px;padding:10px 12px;
         box-shadow:0 6px 16px rgba(0,0,0,.2);z-index:25}
  .row{display:flex;gap:10px;align-items:center;margin:4px 0}
  .panel label{font-size:13px}
  .panel input[type=number]{width:70px}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="panel">
  <div class="row">
    <label>Max Tilt Left (°): <input id="maxLeft" type="number" value="75"></label>
    <label>Max Tilt Right (°): <input id="maxRight" type="number" value="75"></label>
  </div>
  <div class="row" style="opacity:.8">
    <label>Sens L/R (°→full): <input id="sensX" type="number" value="30"></label>
    <label>Sens Up (°→full): <input id="sensY" type="number" value="30"></label>
  </div>
</div>

<button id="runBtn">Enable Gyro & Run</button>
<div id="prompt">⚠️ Tap “Allow” when Safari asks for motion access. If you denied before: Settings → Safari → Advanced → Website Data → remove this site, then reload.</div>
<div id="hud">ready…</div>

<script>
/* ---------- canvas ---------- */
const DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
const cvs = document.getElementById('game'); const ctx = cvs.getContext('2d');
function fit(){ cvs.width=Math.floor(innerWidth*DPR); cvs.height=Math.floor(innerHeight*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
addEventListener('resize',fit,{passive:true}); fit();

/* ---------- UI refs ---------- */
const maxLeftInp  = document.getElementById('maxLeft');
const maxRightInp = document.getElementById('maxRight');
const sensXInp    = document.getElementById('sensX');
const sensYInp    = document.getElementById('sensY');

/* ---------- world / player ---------- */
const FOCAL = 3600;
const GROUND_Y = Math.floor(innerHeight*0.72);
const mmToPx = 96/25.4, STICK_LEN = 6*mmToPx;

const ball = { x: innerWidth*0.5, y: GROUND_Y-16, r: 18, color: '#0ea5e9' };
let angle = -Math.PI/8;     // current aim (radians)
let targetAngle = angle;    // target from gyro
let arcFactor = 0;          // from forward tilt (beta)

/* ---------- projectiles ---------- */
const BULLET_SPD_XY = 420;
const BULLET_SPD_Z  = 380;
const BULLET_GRAV   = 420;
const BULLET_R      = 5;
const FIRE_RATE     = 2;     // bullets/sec
const FIRE_INTERVAL = 1/FIRE_RATE;

let bullets = [];

/* ---------- gyro ---------- */
let gyroEnabled=false, gyroDetected=false, lastGamma=0,lastBeta=0;
function clamp(v,min,max){return Math.max(min,Math.min(max,v));}

function limits(){
  // Get current limit values in radians (from vertical)
  const leftDeg  = parseFloat(maxLeftInp.value)||0;
  const rightDeg = parseFloat(maxRightInp.value)||0;
  const center   = -Math.PI/2;
  return {
    minA: center - leftDeg  * Math.PI/180,
    maxA: center + rightDeg * Math.PI/180
  };
}
function computeAngle(nx,ny){
  // Convert normalized tilt (-1..1) to aim; forbid downward shots
  let a = Math.atan2(-ny, nx||1e-5);        // up is -y
  const {minA,maxA} = limits();
  a = Math.min(0, Math.max(minA, Math.min(maxA, a)));
  return a;
}
function onDeviceOrientation(e){
  gyroDetected = true;
  const gamma=e.gamma??0, beta=e.beta??0;   // L/R, F/B
  lastGamma=gamma; lastBeta=beta;
  const sx = parseFloat(sensXInp.value)||30;
  const sy = parseFloat(sensYInp.value)||30;
  const nx=clamp(gamma/sx,-1,1);
  const ny=clamp(beta /sy,-1,1);
  targetAngle = computeAngle(nx,ny);
  arcFactor = ny;                            // +upward bias with forward tilt
}
async function enableGyro(){
  try{
    if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
      const res=await DeviceOrientationEvent.requestPermission();
      if(res!=='granted') throw new Error('Permission not granted');
    }
    addEventListener('deviceorientation', onDeviceOrientation, true);
    gyroEnabled=true; document.getElementById('prompt').style.display='none';
    return true;
  }catch(err){
    const p=document.getElementById('prompt');
    p.textContent='Gyro error: '+(err?.message||err); p.style.display='block';
    return false;
  }
}

/* ---------- keep-on-screen constraint ---------- */
function constrainAngleForScreen(a, originX, viewW){
  const horizonZ = 1800;
  const vz0 = BULLET_SPD_Z*(1 + arcFactor*1.5);
  const t = Math.max(0.5, horizonZ / Math.max(60, vz0));
  const desiredVx = Math.cos(a)*BULLET_SPD_XY;
  const leftRoom  = Math.max(0, originX - 28);
  const rightRoom = Math.max(0, (viewW-28) - originX);
  const maxVxPos = rightRoom/t, maxVxNeg = leftRoom/t;
  let capVx = desiredVx;
  if(desiredVx > 0 && desiredVx > maxVxPos) capVx = maxVxPos;
  if(desiredVx < 0 && -desiredVx > maxVxNeg) capVx = -maxVxNeg;
  const vyUnit = Math.sin(a);
  const aFromCap = Math.atan2(vyUnit, capVx / BULLET_SPD_XY);
  const capRatio = Math.abs(capVx)/Math.max(1e-6, Math.abs(desiredVx));
  const bias = 1 - capRatio;                       // more cap → more upward bias
  const blended = aFromCap + (0 - aFromCap)*Math.min(1, Math.max(0, bias));
  const {minA,maxA} = limits();
  return Math.min(0, Math.max(minA, Math.min(maxA, blended)));
}

/* ---------- preview & guides ---------- */
function drawTrajectoryPreview(ox,oy,ang,vz0){
  const dt=1/60; let x=ox,y=oy; let vx=Math.cos(ang)*BULLET_SPD_XY, vy=Math.sin(ang)*BULLET_SPD_XY, vz=vz0;
  ctx.save(); ctx.globalAlpha=.7; ctx.setLineDash([6,6]); ctx.lineWidth=2; ctx.strokeStyle='rgba(17,17,17,.55)';
  ctx.beginPath(); ctx.moveTo(x,y);
  for(let t=0;t<2.5;t+=dt){
    vx*=(1-dt*0.15); vz*=(1-dt*0.15); vy+=BULLET_GRAV*dt;
    x+=vx*dt; y+=vy*dt;
    if(x<-100||x>innerWidth+100||y>innerHeight+100) break;
    ctx.lineTo(x,y);
  }
  ctx.stroke(); ctx.setLineDash([]); ctx.restore();
}
function drawLimitGuides(cx,cy,len){
  const {minA,maxA}=limits();
  ctx.save();
  ctx.strokeStyle='rgba(0,0,0,.3)';
  ctx.setLineDash([4,4]); ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(minA)*len, cy+Math.sin(minA)*len); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(maxA)*len, cy+Math.sin(maxA)*len); ctx.stroke();
  ctx.restore();
}

/* ---------- game loop ---------- */
let rafId=0;
function startGame(){
  let fireAcc=0;
  let last=performance.now();

  function loop(t){
    const dt=Math.min(0.033,(t-last)/1000||0); last=t;

    // aim easing toward constrained angle (keeps shots visible)
    const constrained = constrainAngleForScreen(targetAngle, ball.x, innerWidth);
    angle += (constrained - angle) * Math.min(1, dt*12);

    // spawn bullets at steady rate
    const vz0 = BULLET_SPD_Z*(1 + arcFactor*1.5);
    fireAcc+=dt;
    while(fireAcc >= FIRE_INTERVAL){
      fireAcc -= FIRE_INTERVAL;
      bullets.push({
        x: ball.x + Math.cos(angle)*STICK_LEN,
        y: ball.y + Math.sin(angle)*STICK_LEN,
        z: 0,
        vx: Math.cos(angle)*BULLET_SPD_XY,
        vy: Math.sin(angle)*BULLET_SPD_XY,
        vz: vz0,
        age: 0, ttl: 6
      });
    }

    // integrate bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      b.vx*=(1-dt*0.15); b.vz*=(1-dt*0.15); b.vy+=BULLET_GRAV*dt;
      b.x+=b.vx*dt; b.y+=b.vy*dt; b.z+=b.vz*dt;
      b.age+=dt; b.ttl-=dt; if(b.ttl<=0) bullets.splice(i,1);
    }

    // draw
    if(innerWidth!==cvs.width/DPR||innerHeight!==cvs.height/DPR) fit();
    const W=innerWidth, H=innerHeight;
    ctx.clearRect(0,0,W,H);
    const sky=ctx.createLinearGradient(0,0,0,H); sky.addColorStop(0,'#e3f2fd'); sky.addColorStop(1,'#cfe8ff');
    ctx.fillStyle=sky; ctx.fillRect(0,0,W,H);

    // ground horizon (thin line, optional)
    ctx.fillStyle='#cfe8ff'; ctx.fillRect(0, GROUND_Y+ball.r, W, 2);

    // limits + preview
    const ex=ball.x+Math.cos(angle)*STICK_LEN, ey=ball.y+Math.sin(angle)*STICK_LEN;
    drawLimitGuides(ball.x, ball.y, 180);
    drawTrajectoryPreview(ex,ey,angle,BULLET_SPD_Z*(1+arcFactor*1.5));

    // stick & player
    ctx.strokeStyle='#111'; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(ball.x,ball.y); ctx.lineTo(ex,ey); ctx.stroke();
    ctx.fillStyle=ball.color; ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill();

    // bullets with perspective size & exponential ease-out to base size
    for(const b of bullets){
      const p = FOCAL/(FOCAL + Math.max(0, b.z));
      const base=BULLET_R*Math.max(.2,p);
      const tNorm=Math.min(1, Math.max(0, b.age/1.2));
      const expEase=1-Math.exp(-3*tNorm);
      const r=base*(4 - 3*expEase);
      ctx.fillStyle='#ef4444'; ctx.beginPath(); ctx.arc(b.x,b.y,r,0,Math.PI*2); ctx.fill();
    }

    document.getElementById('hud').textContent =
      `bullets=${bullets.length}  angle=${(angle*180/Math.PI).toFixed(1)}°  γ=${lastGamma.toFixed(1)}°  β=${lastBeta.toFixed(1)}°`;

    rafId=requestAnimationFrame(loop);
  }
  loop(last);

  setTimeout(()=>{ if(!gyroDetected) document.getElementById('prompt').style.display='block'; },3000);
}

/* ---------- start button ---------- */
document.getElementById('runBtn').addEventListener('click', async()=>{
  if(rafId) cancelAnimationFrame(rafId);
  const ok = await enableGyro();
  if(ok) startGame();
});
</script>
</body>
</html>
